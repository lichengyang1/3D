# 中级实训总结报告

## 阶段一

### 实验目的

* 本阶段主要是为实训项目做基本的技术准备，学会使用**Vi**、**JAVA**、**Ant**、  **Junit**、**sonarQube**等工具辅助完成项目
* 初步了解**GridWorld**的使用，并完成指定的任务。



### 实验内容

1. 学习**vim**编辑器的使用，包括**vim**更人性化的配置、命令模式下的各种命令的学习和熟悉。
2. 配置**JDK**，配置**JAVA**环境变量，学会在LINUX终端下编译并运行简单的**JAVA**代码文件——`HelloWorld.java`。
3. 学习**Ant**的使用，并利用**Ant**进行代码的自动编译、运行。
4. 用**JAVA**实现简单计算器。
5. 学习使用**Junit**来对**JAVA**文件进行测试。
6. 学习使用**sonar-qube**对**JAVA**文件进行规范性检查。
7. 完成GridWorld的环境配置，学习`gridworld.jar`的引用，编译运行`BugRunner`



### 实验总结与感想

* 本次实验最大的收获是学会了各种工具的使用以及复习了**JAVA**相关知识

  * **Vim**编辑器在LINUX下提供查看文件、在文件中移动、插入、编辑和替换文本等基本功能，且具备多种快捷键方便操作。

  * 关于在终端下编译并允许**JAVA**文件，这可以说是本阶段最令人困扰的地方。由于云桌面上的环境变量有问题，因此需要使用**Vim**编辑器对环境变量进行修改。

  * **Ant**帮助自动编译和执行代码，在学习的过程中感觉像是另一个版本的**makefile**，都是编写脚本来指定任务。

  * **Junit**进行单元测试，难点在于额外编写测试案例并运行测试案例。

  * **sonar-qube**能对JAVA进行规范性检查并反馈信息帮助程序员优化代码，由于网站上提供了傻瓜式教程，使用起来还是相当容易的。该工具能对代码进行多方面的测试，包括复杂度、覆盖率、文档、重复等。

  * 在编译运行GridWorld时遇到了较大的困难。因为一开始不知道如何在编译时调用gridworld.jar，再加上环境变量的问题，所以在这里耗费了很多时间。

    * 解决：

      在目录GridWorldCode/projects/firstProject下执行以下命令

      ```java
      ## 编译：
      javac -classpath .:./../../gridworld.jar BugRunner.java
      ## 执行：
      java  -classpath .:./../../gridworld.jar BugRuner
      ```

* 经过阶段一的学习，我学会了多种辅助工具的使用，锻炼了自学能力也提高了编程能力。相信在之后的编程生涯中，这些工具会为我提供一定助力。



## 阶段二

### 实验目的

* 开始进行GridWorld项目，熟悉GridWorld项目的整个文件结构和运行结构。
* 重点是各种各样的成员类的实现。

### 实验内容

1. 了解各种基础成员类：`Actor`、`Bug`、`Rock`、`Flower`等的实现方法，它们的行为表现和实现方法。

2. 实现复杂的派生成员类：`ZBug`、`BlusterCritter`、`KingCrab`、`QuickCrab`等，通过`Override`方法来实现不同行为。

3. 多种方式实现不一样的`Grid`布局，包括`BoundedGrid`和`UnboundedGrid`

   * 通过`SparseGridNode` + `ArrayList<>`或`Array[]`实现
   * 通过`LinkedList<OccupantInCol>`实现，
   * 通过`HashMap`来实现
   * 通过`TreeMap`实现，

   比较这几种方式实现的优劣，以及它们的复杂度。

4. 完成与项目相关的多个问答题。

### 实验总结与感想

* 本阶段从内到外剖析了项目的组成，从项目的基础成员类到界面GUI，由此展示了一个完整项目的结构。本阶段的核心就是多态，通过不断地重写父类方法使同一个行为具有多个不同表现形式，完成不同功能，由此派生出多种多样的子类，从基础成员类到各种Grid布局都是如此。多态的灵活性和可扩展性体现的淋漓尽致。

* 本阶段难度并不高，跟着问答题与题目前的项目介绍走就可以轻松完成。但问答题比较麻烦，要贴代码和描述代码位置，耗费太多时间。很多问答题内容都有重复交叉，可以考虑减少部分问答题。

* 本阶段的主要困难在于Part5。在运行时发现单在main函数中使用addGridClass方法并不能改变GUI，个人认为由于Part5要改变GUI，因此要重新编译生成新的GridWorld.jar包，否则会一直调用旧的UI界面，无法选择各种Grid。这部分编程是在eclipse上进行的，难点就是如何生成新jar包并在eclipse中调用。

  * 解决：

    1. 生成jar包：
       * 更新framework中的相关代码，然后在项目目录下进行ant
       * 编译完成后在文件夹dist中即可得到新的jar包

    2. 在ecplise中调用：
       * 相关教程在网站上有，就不再赘述。关键点是要先在eclipse上删掉原有的jar包关联，然后再添加新的jar关联。

      

## 阶段三

### 实验目的

* 完成GridWorld项目的扩展项目，包括图像处理、迷宫和拼图



### 实验内容

1. 图像处理
   * 利用二进制流读取Bitmap位图文件。注意，这里要求不能使用Java提供的API直接读取图像，根据二进制数据创建Image时可以使用API。
   * 把读取彩色图像转换成灰度图像。
   * 提取并且显示彩色图像各个色彩通道。
   * 把处理完的图像保存为bmp格式图像。注意，这里可以使用Java提供的API完成。
   * 编写Junit测试程序，测试输出的图片是否与goal文件夹下的图片一致。（比较位图宽度、位图高度以及像素值）
2. 迷宫：
   * 基于GridWorld项目下，利用深度优先搜索算法和启发式算法，实现虫子走出迷宫。
3. 拼图：
   * N-数码问题，利用广度优先搜索算法和启发函数来完成拼图任务。



### 实验总结与感想

* 通过图像处理项目

  * 了解到了Bitmap图片文件的存储结构，深入到每个字节的所属区域。

  * 了解到了简单的图像处理方法，如提取色彩通道获得单色图，通过彩色图获得灰度图。在这个过程中，困扰我最久的地方就是图像上的像素值组成。

    * 在最开始时，我认为像素值由RGB三种颜色值通过移位组合而成，如下：

      ```java
      pixel[index++]=(red<<16)|(green<<8)|(blue);
      ```

      结果发现不行

    * 后来经过多种尝试，不断改变移位发现都不能显示正确结果。于是我通过Java提供的API直接获得图像，然后通过该图像的像素值反推正确的像素组成结构。经过测试发现，像素的最高8位对应值为-1，而在之前的尝试中最高8位我都默认为0。修改后：

      ```java
      pixel[index++]=(-1<<24)|(red<<16)|(green<<8)|(blue);
      ```

      获得正确图像

  * 了解到了JAVA中图像的相关处理方法。在JAVA中，Image是一个抽象类，BufferedImage是其实现类。Image只提供了一些基础方法，如获得分辨率等，并不能直接对存储的像素矩阵进行操作；而BufferedImage是一个带缓冲区图像类，主要作用是将一幅图片加载到内存中，提供获得绘图对象、图像缩放、选择图像平滑度等功能，可以很方便地进行图像处理。因此实验的一个难点是完成从Image到BufferedImage的转化。

    * 解决：

      * 经过查询资料了解到，通过Java游戏引擎可以进行转化如下：

        ```java
        // Create a buffered image with transparency
        BufferedImage bimage = new BufferedImage(img.getWidth(null), img.getHeight(null), BufferedImage.TYPE_INT_ARGB);
        
        // Draw the image on to the buffered image
        Graphics2D bGr = bimage.createGraphics();
        bGr.drawImage(img, 0, 0, null);
        bGr.dispose();
        ```

* 在mazeBug中介绍了深度优先搜索算法，由此深入了解了深搜

  1. 先将树的所有节点标记为”未访问”状态。

  2. 输出起始节点，将起始节点标记为”已访问”状态。

  3. 将起始节点入栈。

  4. 当栈非空时重复执行以下步骤：

     a. 取当前栈顶节点。

     b. 如果当前栈顶节点是结束节点（迷宫出口），输出该节点，结束搜索。

     c. 如果当前栈顶节点存在”未访问”状态的邻接节点，则选择一个未访问节点，置为”已访问”状态，并将它入栈，继续步骤a。

     d. 如果当前栈顶节点不存在”未访问”状态的邻接节点，则将栈顶节点出栈，继续步骤a。

* 在拼图中，最大的收获就是启发式搜索

  * 早在项目之前，我就已经在专选课人工智能上了解到了启发式搜索的相关知识。

    * 与一般搜索不同，启发式搜索利用问题拥有的启发信息来引导搜索，动态地确定搜索节点的排序，以达到减少搜索范围，降低问题复杂度的目的。

    * 在N-数码问题中，每搜索到每一个节点时，通过估价函数对该节点进行评估获得启发式信息，然后优先访问最优节点的邻接节点，能够大大减少求解的时间。

    * 算法如下

      1. 将起始节点放入一个列表中。

      2. 如果列表为空，则搜索失败，问题无解；否则重复以下步骤：

         a. 访问列表中的第一个节点v，若v为目标节点，则搜索成功，退出。

         b. 从列表中删除节点v。

         c. 利用估价函数，对所有与v邻接且未曾被发现的节点进行估价，按照估价大小（小的在前）插入列表中。



## 实训总结

虽然本次实训耗费了大量时间，占用了宝贵的周末时间，但是从中我也受益匪浅。在实训中，我不仅在编程的理论知识上有了更多积累和深化，还有了进行项目开发锻炼能力的经验。我看到了自己的无知，并使其成为学习的动力，督促自己在学习的过程中不断的完善自我。实训即将结束，在此感谢TA们的辛苦付出和热心帮助。

